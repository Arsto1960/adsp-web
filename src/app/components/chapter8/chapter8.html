<div class="m-5 overflow-hidden space-y-6 max-w-[1400px] mx-auto">
  
  <div class="text-3xl font-sans font-semibold">
    <h1>Chapter 8 : Filters, Noble Identities</h1>
  </div>

  <div>
    <mat-card class="example-card text-2xl" appearance="outlined" style="background-color: #6AECE1;">
      <mat-card-header>
        <mat-card-title style="color: blue;">Learning Objectives</mat-card-title>
      </mat-card-header>
      <mat-card-content class="text-lg">
        <ul class="space-y-4 m-4 list-disc">
          <li>Understand filter design principles.</li>
          <li>Learn how group delay and linear phase affect signal processing.</li>
          <li>Design FIR filters using optimization methods (Parks-McLellan / remez algorithm).</li>
          <li>Apply Noble Identities to exchange downsampling and upsampling.</li>
        </ul>
      </mat-card-content>
    </mat-card>
  </div>

  <div>
    <mat-card class="example-card text-2xl" appearance="outlined">
      <mat-card-content class="text-lg gap-4">
        <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
          8.1 Filter Design 
        </h3>

        <p class="mt-3">
          How do we design filters, such that they have desired properties? First we should know how the ideal or desired filter should look like. In general, we specify the frequency responses with magnitude and phase.
        </p>

        <p class="mt-3">
          The frequency response is written in the form:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(\Omega) = e^{j\phi(\Omega)} \cdot A(\Omega) $$"></p>

        <p class="mt-3">
          phi(Omega) is the phase as a function of the normalized frequency Omega, and A(Omega) is the magnitude. When designing a filter, we must specify both the phase and the magnitude.
        </p>

        <h3 class="mt-6 text-xl font-semibold text-blue-800">8.1.1 Phase and Signal Delay</h3>

        <p class="mt-3">
          The phase angle of a system is directly connected to the delay introduced by that system. Consider a pure delay of <code>d</code> samples, which has the transfer function:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(z) = z^{-d} $$"></p>

        <p class="mt-3">
          To obtain the frequency response in the Discrete Time Fourier Transform (DTFT) domain, we replace <code>z</code> with <code>exp(j * Omega)</code>:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ He^{jŒ©} = e^{-jŒ©.d} $$"></p>

        <p class="mt-3">
          Thus the phase response is:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ \phi(\Omega) = \,angle(e^{-jŒ©.d}) = -\Omega \cdot d $$"></p>

        <p class="mt-3">
          Conversely, we can obtain the delay in samples by dividing the phase angle by the normalized frequency:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ d = \frac{-\,angle\left(H(e^{j\Omega})\right)}{\Omega} $$"></p>

        <p class="mt-3">
          In Python, the function <code>np.angle()</code> returns the angle of a complex number in radians (between 0 and 2œÄ), matching our normalized frequency range.
        </p>

        <p class="mt-3">
          If the phase angle is a linear function of Omega with slope <code>-d</code>, the system is said to have <b>linear phase</b>. Only in this case do all frequencies experience the same delay. This is crucial in applications like image processing: edges contain many frequencies, and different delays across frequencies would blur the edges.
        </p>

        <p class="mt-3">
          In general, the negative derivative of the phase with respect to Omega is called the <b>group delay</b>. If the group delay is written as <code>d_g(Omega)</code>, it is defined as:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ d_g(\Omega) = \frac{-\,d\phi(\Omega)}{d\Omega} $$"></p>

        <p class="mt-3">
          This tells us how much delay each frequency component experiences when passing through the system. When designing filters, understanding and controlling this delay behavior is essential.
        </p>

        <h3 class="mt-6 text-xl font-semibold text-blue-800">8.1.2 Magnitude Design</h3>

        <p class="mt-3">
          To design a filter, we must specify the desired magnitude response A(Omega). Many filters aim to have one or more pass bands, where the signal is passed with nearly 0 dB attenuation, and one or more stop bands, where the signal is strongly attenuated.
        </p>

        

        <p class="mt-3">
          For an FIR filter, the filter coefficients correspond to its impulse response. The ideal impulse response can be obtained from the desired frequency response H(exp(j * Omega)) using the inverse DTFT.
        </p>

        <p class="mt-3">
          h(n) = (1 / (2*pi)) * integral from -pi to pi of [ H(exp(j * Omega)) * exp(j * Omega * n) dOmega ]
        </p>

        <p class="mt-3">
          This impulse response is infinitely long and extends into the past and future. Because such an ideal filter cannot be realized, we must approximate the desired frequency response by minimizing some error function.
        </p>

        <p class="mt-3">
          Since real filters cannot have perfect transitions, every design must include a transition band between each pass band and stop band.
        </p>

        <div class="mt-4 bg-blue-50 p-4 border-l-4 border-blue-500 rounded">
          <strong>Example:</strong> Consider designing a half-band low-pass filter. We want the pass band from 0 to pi/2. For sampling-rate conversion with a downsampling factor of 2, the stop band must begin at pi/2. To provide a transition, we might define the transition band from (pi/2 - 0.1) to pi/2. The pass band is then from 0 to (pi/2 - 0.1).
        </div>

        <p class="mt-3">
          Common error functions include:
        </p>
        <ul class="space-y-2 m-4 list-disc">
          <li>Mean squared error</li>
          <li>Mean absolute error</li>
          <li>Weighted mean squared error</li>
          <li>Minimax error (minimize the maximum deviation)</li>
        </ul>

        <p class="mt-3">
          For FIR linear-phase filters, Python provides the <code>remez</code> function, which implements the Parks‚ÄìMcClellan algorithm based on the Chebyshev approximation. This algorithm minimizes the maximum error in each band (with weights), producing an equiripple response.
        </p>

        <pre class="bg-gray-100 text-sm p-4 rounded-lg overflow-x-auto font-mono mt-2 border border-gray-300">h_min = scipy.signal.remez(N, F, A, W)</pre>

        <h3 class="mt-6 text-xl font-semibold text-blue-800">8.1.3 Python Example</h3>

        <pre class="bg-gray-100 text-sm p-4 rounded-lg overflow-x-auto font-mono mt-2 border border-gray-300">
ipython --pylab
import scipy.signal as sp
N=8;
F = [0.0, 0.5/2 - 0.05, 0.5/2, 0.5]
A = [1.0, 0.0]
W = [1, 100]
hmin = sp.remez(N, F, A, weight=W)
plot(hmin)
xlabel('Sample')
ylabel('Value')
        </pre>

        <div class="flex flex-col justify-center items-center my-6">
          <img src="assets/images/chap8/fig8.1.png" class="max-w-full md:max-w-xl h-auto rounded shadow-sm">
        </div>

        <p class="mt-3">
          Now we obtain a nice impulse response or set of coefficients hmin, which can be seen in Fig. (8.1). and its frequencies response is obtained with
        </p>

        <pre class="bg-gray-100 text-sm p-4 rounded-lg overflow-x-auto font-mono mt-2 border border-gray-300">
from freqz import freqz
freqz(hmin)
        </pre>

        <p class="mt-3">
          and can be seen in Fig. (8.2). Here we see that we obtain an amplitude gain of about -40 dB in the stop band, or about 40 dB of stop band attenuation, which roughly corresponds to our weight of 100 for the stop band.
        </p>

        <p class="mt-3">
          The phase (angle) plot has straight lines, which shows that this is a linear phase filter. Observe that the angle is 2œÄ periodic, hence this plot is not unique and has jumps.
        </p>

        <h3 class="mt-6 text-xl font-semibold text-blue-800">8.1.4 Example with Sound</h3>

        <p class="mt-3">
          We have 8000 Hz sampling rate, and want to build a band pass filter. Our low stop band is between 0 and 0.05, our pass band between 0.1 and 0.2, and high stop band between 0.3 and 0.5 (again with 0.5 as Nyquist frequency and 1 as sampling frequency).
        </p>

        <div class="flex flex-col justify-center items-center my-6">
           <img src="assets/images/chap8/fig8.2.png" class="max-w-full md:max-w-xl h-auto rounded shadow-sm">
        </div>

        <pre class="bg-gray-100 text-sm p-4 rounded-lg overflow-x-auto font-mono mt-2 border border-gray-300">
python3
import numpy as np
import scipy.signal
import matplotlib.pyplot as plt
N=32
bpass=scipy.signal.remez(N, [0.0, 0.05, 0.1, 0.2, 0.3, 0.5] ,\
[0.0, 1.0, 0.0], weight=[100.0, 1.0, 100.0])
[freq, response] = scipy.signal.freqz(bpass)
plt.plot(freq, 20*np.log10(np.abs(response)+1e-6))
plt.xlabel('Normalized Frequency (pi is Nyquist Frequency)')
plt.ylabel(Magnitude of Frequency Response in dB)
plt.title(Magnitude of Frequency Response for our Bandbass Filter)
plt.show()
        </pre>

        <p class="mt-3">
          The resulting plot can be seen in Fig. (8.3). Observe: The equi-ripple behaviour inside each band is clearly visible, and we see our pass band a little left of the center.
        </p>

        <div class="flex flex-col justify-center items-center my-6">
          <img src="assets/images/chap8/fig8.3.png" class="max-w-full md:max-w-xl h-auto rounded shadow-sm">
        </div>

        <pre class="bg-gray-100 text-sm p-4 rounded-lg overflow-x-auto font-mono mt-2 border border-gray-300">
plt.plot(bpass)
plt.title('Impulse Response of our Bandpass Filter')
plt.show()
        </pre>

        <p class="mt-3">
          which can be seen in Fig. (8.4). Observe: The impulse response is symmetric around the center, because it is a linear phase filter, and it still has similarity with a sinc function.
        </p>
        
        <pre class="bg-gray-100 text-sm p-4 rounded-lg overflow-x-auto font-mono mt-2 border border-gray-300">
python pyrecplay_filterblock.py
        </pre>

        <div class="flex flex-col justify-center items-center my-6">
          <img src="assets/images/chap8/fig8.4.png" class="max-w-full md:max-w-xl h-auto rounded shadow-sm">
        </div>

        <p class="mt-3">
          Observe: Speech sounds like through a very cheap telephone, since only a small band is left of it (telephone bandwidth is about 0.3 to 3.4 kHz).
        </p>

      </mat-card-content>
    </mat-card>
  </div>

  <div>
    <mat-card class="example-card text-2xl" appearance="outlined">
      <mat-card-content class="text-lg gap-4">
        <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
          8.2 Filtering and Sampling, Multirate Noble Identities
        </h3>

        <p class="mt-3">
          This section discusses filtering and sampling in multirate systems. The Noble Identities describe when filtering can be exchanged with downsampling or upsampling.
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ \downarrow N \circ H(z) = H(z^N) \circ \downarrow N \\ \uparrow N \circ H(z) = H(z^N) \circ \uparrow N \tag{8.1} $$"></p>

        <p class="mt-3">
          The identities can be written in plain text as:
          <br>
          Downsampling by N followed by filter H(z) = filter H(z raised to the power N) followed by downsampling by N
          <br>
          Upsampling by N followed by filter H(z) = filter H(z raised to the power N) followed by upsampling by N
        </p>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 my-6">
          <div class="flex flex-col items-center">
            <img src="assets/images/chap8/fig8.5.png" class="max-w-full h-auto rounded shadow-sm">
          </div>
          <div class="flex flex-col items-center">
             <img src="assets/images/chap8/fig8.6.png" class="max-w-full h-auto rounded shadow-sm">
          </div>
        </div>

        <p class="mt-3">
          If we take H(z) and replace z with z raised to N, the impulse response becomes upsampled. For example:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(z) = 1 + z-1 ¬∑ 2 + z-2 ¬∑ 3 $$"></p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(z2) = 1 + z-2 ¬∑ 2 + z-4 ¬∑ 3 $$"></p>

        <p class="mt-3">
          The corresponding impulse response is:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ hu = [1, 0, 2, 0, 3] $$"></p>

        <p class="mt-3">
          This happens because inserting zeros between coefficients spreads the impulse response. The Noble Identities show when sampling and filtering can be swapped without changing the result.
        </p>

        <h4 class="text-xl font-semibold mt-4">Example</h4>
        <p class="mt-3">
          Take a simple running-average FIR filter: <code>B = [1, 1]</code> and input <code>x = [1, 2, 3, 4, ...]</code>.
        </p>

        <div class="flex flex-col justify-center items-center my-6">
          <img src="assets/images/chap8/fig8.7.png" class="max-w-full md:max-w-xl h-auto rounded shadow-sm">
        </div>

        <pre class="bg-gray-100 text-sm p-4 rounded-lg overflow-x-auto font-mono mt-2 border border-gray-300">
# N=2:
xd = x[::N]
# This yields xd=1,3,5,7,9
# Then apply the filter B=[1,1],
y1 = scipy.signal.lfilter(B, 1, xd)
# This yields the sum of each pair in xd: y1= 1,4,8,12,16

# Right-hand side:
Bu = np.zeros(3)
Bu[::N] = B
# This yields Bu= 1,0,1
yu = scipy.signal.lfilter(Bu, 1, x)
# This yields yu= 1, 2, 4, 6, 8, 10, 12, 14, 16, 18
y2 = yu[::N]
# This yields y2= 1,4,8,12,16
# y1=y2!
        </pre>
      </mat-card-content>
    </mat-card>
  </div>

  <div>
    <mat-card class="example-card text-2xl" appearance="outlined">
      <mat-card-content class="text-lg gap-4">
        <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
          8.3 Polyphase Representation
        </h3>

        <p class="mt-3">
          The Noble identities allow the construction of efficient sampling-rate‚Äìconversion systems.
        </p>

        <p class="mt-3">
          The general polyphase decomposition of a filter is:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(z) = H_0(z^N) + H_1(z^N)\cdot z^{-1} + \ldots + H_{N-1}(z^N)\cdot z^{-(N-1)} $$"></p>

        <p class="mt-3">
          Figures (8.8) and (8.9) show how a simple signal can be decomposed into N upsampled polyphase components for N = 3.
        </p>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 my-6">
          <div class="flex flex-col items-center">
            <img src="assets/images/chap8/fig8.8.png" class="max-w-full h-auto rounded shadow-sm">
          </div>
          <div class="flex flex-col items-center">
             <img src="assets/images/chap8/fig8.9.png" class="max-w-full h-auto rounded shadow-sm">
          </div>
        </div>

        <h4 class="text-xl font-semibold mt-4">Example</h4>
        <p class="mt-3">
          Suppose the filter impulse response is $h = [1, 2, 3, 4, \ldots]$. With N = 2, the polyphase components become:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H_0(z^2) = 1 + 3z^{-2} + 5z^{-4} + \ldots \\ H_1(z^2) = 2 + 4z^{-2} + 6z^{-4} + \ldots $$"></p>

        <p class="mt-3">
          Thus the complete filter can be reconstructed as:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(z) = H_0(z^2) + z^{-1}H_1(z^2) $$"></p>

        <p class="mt-3">
          A block diagram (Fig. 8.10) illustrates this structure.
        </p>

        

        <p class="mt-3">
          Using the Noble identities, we move the downsamplers before the filters. This transforms $H_i(z^N)$ into $H_i(z)$, greatly simplifying the system (as shown in Fig. 8.11).
        </p>

        <div class="flex flex-col justify-center items-center my-6">
           <img src="assets/images/chap8/fig8.11.png" class="max-w-full md:max-w-xl h-auto rounded shadow-sm">
        </div>

        <p class="mt-3">
          This can be expressed as a vector multiplication:
        </p>
        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ [X_0(z), \ldots, X_{N-1}(z)] \cdot [H_0(z), \ldots, H_{N-1}(z)]^T = Y(z) $$"></p>

        <h3 class="text-xl font-semibold mt-6 text-blue-800">8.3.2 Noble Identities for Upsampling</h3>

        <p class="mt-3">
          Correspondingly, up-samplers can also be implemented with filters operating at the lower sampling rate.
        </p>

        <div class="flex flex-col justify-center items-center my-6">
          <img src="assets/images/chap8/fig8.12.png" class="max-w-full md:max-w-xl h-auto rounded shadow-sm">
        </div>

        <h3 class="text-xl font-semibold mt-6 text-blue-800">8.3.3 Example Upsampling</h3>

        <pre class="bg-gray-100 text-sm p-4 rounded-lg overflow-x-auto font-mono mt-2 border border-gray-300">
ipython --pylab
import scipy.signal
from sound import *
# up-sample the signal y by a factor of N=2
h = np.array([0.5, 1, 1.1, 0.6])
h0 = h[0::2]
h1 = h[1::2]
y0 = scipy.signal.lfilter(h0,1,y)
y1 = scipy.signal.lfilter(h1,1,y)

L = max([len(y0), len(y1)])
yu = zeros(2*L)
yu[0::2] = y0
yu[1::2] = y1

sound(yu*0.3,fs);
        </pre>

      </mat-card-content>
    </mat-card>
  </div>

  <div class="h-6"></div>

  <div class="flex flex-col items-center p-3 gap-6">
    <h2 class="text-2xl font-sans font-semibold mb-4">üß† Test Your Knowledge</h2>

    @for (q of questions; track q) {
      <div class="w-full md:w-2/3">
        <mat-card class="mat-elevation-z6 p-6 font-sans">
          <mat-card-title>{{ q.text }}</mat-card-title>
          <br>
          <mat-card-content>
            <mat-radio-group [(ngModel)]="q.selectedAnswer" [disabled]="q.isSubmitted">
              @for (option of q.options; track option) {
                <div class="mb-2">
                  <mat-radio-button [value]="option">{{ option }}</mat-radio-button>
                </div>
              }
            </mat-radio-group>
            <div class="mt-4 flex gap-3">
              <button matFab extended (click)="submitAnswer(q)" [disabled]="!q.selectedAnswer || q.isSubmitted">
                Submit
              </button>
              @if (q.isSubmitted) {
                <button matFab extended style="background-color:black ; color: aliceblue;" (click)="tryAgain(q)">
                  Try Again
                </button>
              }
            </div>
            <div class="mt-4">
              @if (q.isSubmitted && q.selectedAnswer === q.correctAnswer) {
                <p class="text-green-600 font-semibold font-sans">‚úÖ Correct!</p>
              }
              @if (q.isSubmitted && q.selectedAnswer !== q.correctAnswer) {
                <p class="text-red-600 font-semibold font-sans">‚ùå Incorrect. Correct answer: <strong>{{ q.correctAnswer }}</strong>.</p>
              }
            </div>
          </mat-card-content>
        </mat-card>
      </div>
    }
  </div>

</div>